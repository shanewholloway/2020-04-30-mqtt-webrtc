import MQTTClient from 'u8-mqtt/esm/web/v4.mjs'

export default mqtt_presence
export function mqtt_presence(opt={}) ::
  let {pfx, uid} = opt
  const mqtt = new MQTTClient()

  mqtt.msg_to = (peer_uid, msg) =>
    mqtt.json_send @ `${pfx}/m/${peer_uid}/${uid}`, msg

  mqtt.msg_chan = @\ peer_uid ::
    const tpc_send = `${pfx}/m/${peer_uid}/${uid}`
    const tpc_recv = `${pfx}/m/${uid}/${peer_uid}`
    return @:
      json_send: mqtt.json_send(tpc_send)
      on_msg: on_msg => mqtt.msg_subscribe @ tpc_recv, on_msg


  mqtt.on_status = on_status =>
    mqtt.on_msg @ `${pfx}/p/:peer_uid`, @\ pkt, {peer_uid}, ctx ::
      if peer_uid !== uid ::
        on_status(peer_uid, pkt, ctx)

  mqtt.on_any_msg = on_any_msg =>
    mqtt.on_msg @ `${pfx}/m/${uid}/:peer_uid`, @\ pkt, {peer_uid}, ctx ::
      if ctx.idx || peer_uid === uid ::
        return

      return on_any_msg(peer_uid, pkt, ctx)


  const _as_status_obj = status => @:
    topic: `${pfx}/p/${uid}`
    payload: status
    qos: 1, retain: true

  mqtt.update_status = status =>
    mqtt.publish @ _as_status_obj(status)

  mqtt.ready = mqtt
    .with_websock(opt.websock)
    .then(_setup)

  return mqtt

  async function _setup() ::
    mqtt.connect @:
      client_id: `mq-wrtc-${uid}`
      flags: @{} clean_start: true
      will: _as_status_obj('')

    mqtt.subscribe @#
      `${pfx}/p/+`,
      `${pfx}/m/${uid}/+`,

    mqtt.update_status @
      opt.presence || 'here'
