import {mqtt_presence} from './mqtt.jsy'
//import {rtc_initiate, rtc_accept} from './webrtc.jsy'
import {RTCHandshake} from './rtc_handshake.jsy'
import {room_info} from './utils.jsy'


const {room_id, uid} = room_info()
const map_rtc = new Map()

const mqtt = mqtt_presence @:
  pfx: `swh/${room_id}`, uid
  //websock: 'ws://9030.shaneholloway.com:9001'
  websock: 'ws://127.0.0.1:9001'
  //websock: 'wss://test.mosquitto.org:8081'


mqtt.on_status @\ peer_uid, pkt :: 
  const {payload} = pkt
  if ! payload[0] :: return

  const bmoc = sessionStorage.getItem('bmoc')
  if ! bmoc :: return

  if ! map_rtc.has(peer_uid) ::
    const rtc = _new_rtc(peer_uid)
    rtc.rtc_initiate()


mqtt.on_any_msg @\ peer_uid, pkt :: 
  const {payload} = pkt
  if ! map_rtc.has(peer_uid) ::
    const rtc = _new_rtc(peer_uid)
    rtc.on_msg @ pkt.json()

const all_chans = window.swh_all_chans = new Map()
window.swh_send_all = @\ msg ::
  msg = JSON.stringify(msg)
  for const ea of all_chans.values() ::
    ea.send(msg)

function _new_rtc(peer_uid) ::
  const _mqtt_chan = mqtt.msg_chan(peer_uid)
  const rtc = RTCHandshake.create(_mqtt_chan.json_send)
  map_rtc.set @ peer_uid, rtc

  _mqtt_chan.on_msg @ pkt => rtc.on_msg(pkt.json())

  const chan = Object.assign @
    rtc.pc.createDataChannel @ 'mqtt-test', @{}
      ordered: false, id: 0, negotiated: true, maxPacketLifeTime: 250

    @{}
      binaryType: 'arraybuffer'
      onopen() :: all_chans.set(peer_uid, chan)
      onclose() :: all_chans.delete(peer_uid)

      onmessage({data}) ::
        console.log @ `${chan.label}::msg`, Date.now() - new Date(JSON.parse(data).ts)

  return rtc


